
## 数组(array)和切片(slice)

golang里数组和切片是两个不同的数据类型，但又有着微妙的关系，即slice是array的一个view，就是当你创建一个array时，只是创建了一个array，但当你创建一个slice时，背后肯定有个array，不管是你自己声明的或是系统帮你创建的。

### 声明数组

数组声明的基本格式是[n]Type

```go

arr := [5]int{1, 2}

// 或者让计算机告诉我们其长度
arr := [...]int{1, 2, 3}

// 或者带索引的方式设置
arr := [...]string{0: "a", 2: "b", 5: "c"}

```
注意当内容不足定义的长度时，剩余的将会以零值作为填充，但如果超过的话就是编译错误

### 数组按值传递

golang的数组其实是值类型，在作为参数传递给其他函数时是按值传递的，也就是说会拷贝一份，这和大多数的语言表现不一致。

**要注意的是，如果是个[5]int的数组作为参数，func的接收参数也必须是 [5]int 或 \*[5]int ，不然都会编译错误**

**还有要注意的是fun的参数类型不可以是[...]int，也会有编译问题**

```go
func do(arr [5]int) {
  arr[0] = 100
}

arr := [5]int{}

do(arr)

fmt.Println(arr) // -> [0 0 0 0 0]

// 如果需要改变其数据的话需要传递该数组的指针
// 注意参数arr变成了&arr，表明是取地址

func ptrDo(arr *[5]int) {
  arr[0] = 100
}

ptrDo(&arr)

fmt.Println(arr) // -> [100 0 0 0 0]
```

### 数组可以比较

因为他是值类型，所以是可以比较的，他和javascript的表现不同，javascript的数组比较是内存地址的比较，所以要比较内容相同相对困难，golang的数组直接==比较就行，其比较的是内部的数据，而非地址。

**但要注意的是[3]int和[5]int是不同的数据类型，不能比较，会编译错误**

```go

arr1 := [3]int{1, 2, 3}

arr2 := [5]int{1, 2, 3, 4, 5}

arr3 := [3]int{4, 5, 6}

fmt.Println(arr1 == arr2) // -> 编译错误

fmt.Println(arr1 == arr3) // -> 编译正确，但返回false，因为内部数据不同


```

## 其实更多的时候我们使用slice

slice其实是数组的一个view，什么意思呢，下面例子：

```go

arr := [5]int{1, 2, 3, 4, 5}

s := arr[:]

s[0] = 100

fmt.Println(arr) // -> [100, 2, 3, 4, 5]
```

slice映射了这个声明的array，改变其slice之后，array的数据也会跟着改变

### 声明slice

上面例子中我们声明了一个slice，使用的是ar[:]的方式，[:]的意思是[Start:End]，我们可以显式的输入两个int告诉他开始的结束的位置，如果不写，Start默认是0，End默认是其长度，Start和End遵循左开右闭的结构，即包含左边的值不包含右边的值

```go
arr := [5]string{"a", "b", "c", "d", "e"}

s := arr[0:len(arr)] // -> ["a", "b", "c", "d", "e"]

// 上面的写法等同于 arr[:]

s = arr[0:1] // -> ["a"]

s = arr[1:3] // -> ["b", "c"]
```

### slice的直接声明

slice也可以在没有array的情况下直接声明

**但其实系统还是会内建一个array，只是我们看不到，但他是存在的**

```go

s := []int{1, 2, 3} // 其背后隐藏着一个array

// slice可以在slice的基础上再建立一个view

s2 := s[1:3] // -> [2, 3]

// 如果我对s2进行操作
s2[0] = 100

fmt.Println(s2) // -> [100, 3]

// 也是会影响到s这个slice的
// 但s2[0]并不代表s[0]，实际上是影响其对应下标上的值
fmt.Println(s) // -> [1, 100, 3]
```

### slice作为参数是引用传递，和array不同

通过上面的例子这个问题已经显而易见了，而且作为参数传递时他表现的不像array那么的难用

```go
func do(s []int) {
  s[0] = 100
}

s := []int{1, 2, 3}

do(s)

fmt.Println(s) // -> [100, 2, 3]
```

### slice的容量

slice不光有len这个属性，而且还有一个cap，这个是array没有的

```go
arr := [5]int{1, 2, 3, 4, 5}

s := arr[:3] // -> [1, 2, 3]

fmt.Printf("%v", len(s)) // 3

fmt.Printf("%v", cap(s)) // 5 !!!
```

上面例子中，len是3没毛病，因为他就装了3个值，那5哪来的呢

slice还有个特性就是他在view这个数组的时候，他的容量是前面提到的那个Start一直到这个数组的最后的这个长度，也就是说上面的例子中s除了1、2、3，还隐藏着2个数字，4和5！

但Start之前的数据，他就扔掉了

```go

arr := [5]int{1, 2, 3, 4, 5}

s := arr[2:4] // -> [3, 4]

fmt.Printf("%v", len(s)) // 2

fmt.Printf("%v", cap(s)) // 3，因为除了3和5，还隐藏着5

// 那怎么证明5是在的呢

s = s[0:3] // -> [3, 4, 5]
```
注意上面的例子，其实s的长度是2，理论上取s的0:3是会报错的，实际上不是这样，这个End可以超过其len，是可以正常工作并取到相应的值的，但不能超过cap，超过cap的话就真的会报错了

**注意：上面虽然可以使用[:]的方式拿到超过len但不超过cap的数据，但是如果用s[i]这样的方式直接去取超过len的值，实际上是会报错的，即使i没有超过cap**

### slice的追加与删除

系统有内建方法中其实只给了追加的方法

```go
s := []int{1, 2}

s = append(s, 3, 4, 5) // -> [1 2 3 4 5]

// 如果要append另一个slice可以这样
// 在追加的这个slice后面跟...，有点像javascript的解构，只不是解构的...是在前面

s2 := []int{1, 2}

s3 := []int{3, 4, 5}

s4 := append(s2, s3...)
```

既然内建方法中没有删除功能，那我们怎么做呢？

记得[:]吗？用它就可以

```go
s := []int{1, 2, 3}

// 删除头
s2 := s[1:] // -> [2, 3]

// 删除尾
s3 := s[:len(s) - 1] // -> [1, 2]

// 删除中间（比较麻烦，但还是可以做的）
s3 := append(s[:1], s[2:]...) // -> [1, 3]
```

### slice的其他声明方式

即然有cap，那我们如果在声明的时候就把cap值一起声明了呢

要注意的是，cap不能小于len，否则是会报错的
```go

s := make([]int, 3) // 声明3个长度的slice

s2 := make([]int, 3, 16) // 声明长度为3但cap为16的slice

// 也可以这样
// 这里其实有两个步骤
// 1、声明了一个len为16的slice
// 2、通过[:]分割，把他的长度缩减到3
// 其实是利用了cap在len缩减时不会跟着缩减的特性
s3 := make([]int, 16)[:3]
```

在声明的时候就设置cap有什么好处呢？

```go

s := []int{}

for i := 0; i < 100; i++ {
  s = append(s, i)
  fmt.Println(len(s), cap(s))
}

/*
打印结果：
1 1
2 2
3 4
4 4
5 8
6 8
7 8
8 8
9 16
10 16
11 16
12 16
13 16
14 16
15 16
16 16
17 32
...
*/
```

可以看到len在不断增加的同时，cap也会在适合的时机增加，不同的是cap是以2(^n)的形式增加，为什么不和len一样的方式增加呢？

其原因在于，cap在变的时候实际上做了一次array的搬家工作，扔掉原来的那个array，建立一个新的足够长的array，再把数据给考拷贝过来，这个过程是很消耗资源的，所以我们在能预知cap会扩容到多大的情况下，又或者slice会平凡的扩充数据的话，应该在声明的时候就设置他的cap值


### slice的cap引起的一些问题，append并不一定返回一个新的slice

考虑以下问题：

```go

arr := [5]int{1, 2, 3, 4, 5}

s := arr[:] // -> [1, 2, 3, 4, 5]

s2 := s[:2] // -> [1, 2]
s2 = append(s2, 99) // -> [1, 2, 99] 注意，s2的cap有5，足够再加一个99，没有返回一个新的slice

fmt.Println(arr, s, s2)
// arr -> [1, 2, 99, 4, 5]
// s   -> [1, 2, 99, 4, 5]
// s2  -> [1, 2, 99]
```
原因是s2的cap足够长，有5，所以在append的时候，在这个slice的2号下标位置设置为99，但实际上他原来view的是这个arr的3这个值，所以3会被替换99变成这个样子



**但如果cap不够长的时候，就会是另一种表现：**

与上方的例子区别在于，下方的这个s在append的时候，他的cap不够了，所以原来的数组放不下99这个数值了，所以系统会新开一个数组给他，s所view的数组已经不再是arr了

```go
arr := [5]int{1, 2, 3, 4, 5}

s := arr[:]
s = append(s, 99) // -> [1, 2, 3, 4, 5, 99]

fmt.Println(arr, s)
// arr -> [1, 2, 3, 4, 5]
// s   -> [1, 2, 3, 4, 5, 99]

// s已经不再是arr的一个view了
s[0] = 100

fmt.Println(arr, s)
// arr -> [1, 2, 3, 4, 5]
// s   -> [100, 2, 3, 4, 5, 99]
```

### array或slice的遍历

在遍历上，array和slice没有本质上的区别

```go

s := []string{"a", "b", "c", "d", "e"}

// 使用range遍历
for i, v := range s {
  fmt.Println(i, v)
}

/*
0 a
1 b
2 c
3 d
4 e
*/

// 使用for遍历
// 注意的是slice只能用小于len而不能小于cap，前面也提到过如果s[i]的这个i超过len但即便没超过cap，也是会报错的

for i := 0; i < len(s); i++ {
  fmt.Println(s[i])
}

/*
a
b
c
d
e
*/

```

### array或slice的值如果是struct或map类型，可省略其类型

```go

// 值是个map[string]int
s := []map[string]int{
  {"a": 1},
  {"b": 2},
  {"c": 3},
}

type some struct {
  name string
  old  int
}

s2 := []some{
  {name: "eason", old: 18},
  {name: "who?", old: 100},
}

```